---
marp: true
paginate: true
theme: nord
---

# "群れる" アジャイルチームのベストプラクティス

---
<!-- footer: Swarmingとは -->

# Swarmingとは
- 主要な課題にチームのエネルギーを集中させ、チームメンバーが一つに群れることでそれを完了させる。
- Swarmingはアジャイルの根幹を支える動きとして、価値のあるプロダクトを迅速に、頻繁に提供するための活動。


![bg left:40%](./cycle.png)

<!--
アジャイル、スクラム文脈におけるSwarmingでは、主要な課題にチームのエネルギーを集中させ、チームメンバーが一つに群れることでそれを完了させます。

Swarmingはアジャイルの根幹を支える動きとして、価値のあるプロダクトを迅速に、頻繁に提供するための活動です。

Swarimingはよく、インシデントが起こった時にチームメンバー全員で一丸となって立ち向かうイメージが近いと紹介されます。目の前の課題をバックログに積んで後回しにせずに迅速に解決するのが理想的な動きです。

明確なメリットとして、フロー効率を高めることで不確実性に立ち向かいやすくなり、チームの暗黙知を減らしていきます。
-->

---

## 群れる対象の粒度
- 粒度中のイメージで、課題の分割、開発プロセスの改善へと目的を拡げる

![](https://miro.medium.com/v2/resize:fit:2000/format:webp/1*695j-fRaeREANsFViAHqQA.png)
Swarmingの粒度の図[^1]

[^1]: #16
<!--
"群れる" といっても、効果的にSwarmingするためにどの粒度の対象に対して群れるかをチームで定める必要があります。

群れる対象の粒度に関しては、以下の図[^1]が参考になります。


私たちのアジャイルチームでは粒度中のイメージでSwarmingを実践しているため、SprintBacklog単位でSwarmingする日々の経験より得たベストプラクティスを本記事で紹介していきます。

ただ単純にペアプロ、モブプロをして群れればよいという話ではなく、課題の分割、開発プロセスの改善へと目的を拡げる粒度の話になります。

-->

---
<!-- footer: 群れるためにより良いインターフェースを生み出す -->


# 群れるためにより良いインターフェースを生み出す

- 群れでは自己組織化するために秩序を生むと言われる
- シンプルなインターフェースが群れの秩序のような役割を持ちチームメンバーが自律的に働く

![bg left:30%](./swarm.png)

<!--
1つのSprintBacklogに群がるための活動がより良いインターフェースを生み出します。

アジャイル12の原則のうち「設計」のパートに対応するような活動です。

群れでは自己組織化するために秩序を生むと言われますが、シンプルなインターフェースが群れの秩序のような役割を持ちチームメンバーが自律的に働きます。
-->
---

## 自然発生的なモブプロ
- SpritBacklogを独立し依存を最小限にしたサブタスク単位に分割するためモブプロを行う
- モブプロをする目的が「自分のタスクを進めるため」ではなく「チームで群れるため」になる

<!--
着手するSprintBacklogが決まると、独立しており依存を最小限にしたサブタスク単位に分割し、複数のチームメンバーで並行して作業を進めやすい状況を作ります。

チームメンバーはサブタスクが大きい粒度のまま作業に着手しないため、必然的にモブプロを行い設計の方針を立てた上でサブタスクに分割していきます。

モブプロをする目的が「自分のタスクを進めるため」ではなく「チームで群れるため」になるので、モブプロの開催を遠慮することはありません。

モブプロを手段として導入を試みて定期開催するようなことは一切なく、自然発生的にチームメンバーが集まります。
-->
---

## ユースケース駆動実装
- ユースケースが依存するコンポーネントを積極的に抽象化しユースケースを迅速にマージする
  - より自然言語に近い形でユースケースを記述[^2]
- 抽象化に対する実装として責務が明確で独立した並行タスク群を生み出す

[^2]: #16


<!--
シンプルなインターフェースが群れの秩序のような役割を持つ、と言いましたが、果たしてどのレイヤのインターフェースから定めていけばよいのでしょう。

私たちのチームの経験上、ユースケースレイヤの実装から着手し業務フローのインターフェースをいくつか揃えることでその後の並行タスクを効率的に揃えることができます。

ユースケース駆動"実装"という命名の意図は、ユースケース駆動開発におけるユースケースシナリオのドキュメントを記述する代わりに、ユースケースクラスの実装を行うためです。モブプロ内でユースケースクラスの実装とメインブランチへのマージまでを完了させることを目標にします。

（余談ですがチームではextensible effects[^2]によってより自然言語に近く記述が簡潔なユースケース実装を行っています）

ソフトウェア設計でのアーキテクチャでは技術的関心事を抽象化した依存性逆転の法則がよく語られますが、ユースケースクラスが依存するコンポーネントを積極的に抽象化することでインターフェースに対する実装を後回しにした素早いユースケース実装を行います。

後はインターフェースに対する実装をタスクに切ることで、責務が明確で独立した並行タスク群が生まれます。

当たり前ですがインターフェースは意図が明白で小さいシンプルなインターフェースであることが重要です。この設計段階には細心の注意を払います。

また付加的な効果として、ユースケースシナリオは目的不確実性と方法不確実性の双方を俯瞰的に捉えるため、不確実性を早期に潰す効果も生まれます。

-->

---

## 小さいコンウェイの法則
- 群れの形とコンポーネント設計が同期する
- 自己組織的にチームメンバーが責務を遂行していく
<!--
設計の方針を決め複数人のチームメンバーで実際にタスク群に取り組んでいくと、群れの形がそのままコンポーネント設計に反映されるような構図になります。

これは小さい規模でのコンウェイの法則のようなもので、自己組織的にそれぞれのチームメンバーが責務を遂行していきます。
-->
---
<!-- footer: 群れは頻繁に合流する -->

# 群れは頻繁に合流する

![bg left:40%](./flag.jpeg)
- 学習によってインターフェースを変更する際は素早くメインブランチにマージする
- DevOps capabilitiesで語られるような取り組み[^3]

[^3]: #16

<!--
インターフェースによって秩序を定めて実際にサブタスクに取り掛かっていきますが、当たり前に最初から完全なインターフェースは完成できません。

学習によってインターフェースを変更する際は素早くメインブランチに変更をマージし、コンフリクトが起きる前に各メンバーのブランチに取り込みます。

設計によって独立したタスク群を準備した後も、バージョン管理システムによって継続的に並行してタスクを進めやすい開発プロセスを整えていきます。

ここでの内容はDORAによるDevOps capabilities[^3]のうち、「技術に関する能力」のセクションに関連が深いです。
-->
---

## フィーチャーブランチはアンチパターン
- チームの認知負荷を増大させないようブランチ戦略はシンプルに保つ
- どんなSprintBacklogでも常にメインブランチを合流地点にするための工夫をすべき

<!--
Swarmingではチームの認知負荷を増大させないようブランチ戦略はシンプルに保つべきです。

SprintBacklog毎にブランチ戦略を話し合い変化させるよりも、どんなSprintBacklogでも常にメインブランチを合流地点にするための工夫をすべきです。

フィーチャーブランチを用いないことで大規模なマージを防ぎ継続的なインテグレーションを実現します。
-->

---

## ストラングラーパターン[^4]の適用
- 歴史的な文脈が強く密結合なコードでも頻繁な変更を諦めない
- 直接の変更ではなく追加・切替・削除を順に適用する

[^4]: #16

<!--
歴史的な文脈が強く密結合で責務が分散しているコードベースの場合、変更が容易ではないSprintBacklogに立ち向かう時があると思います。

それでもメインブランチへ頻繁に変更をマージすることを諦めてはいけません。

Martin Fowlerが提唱したストラングラーパターン[^4]を適用することで段階的な実装の移行を可能にします。

課題を解決する理想の設計、実装を新規に小さく追加していき、部分的に既存コードを置き換え、最後に既存コードを削除していきます。

ストラングラーパターンは大規模な移行の文脈で語られることが多いですが、小規模なリファクタリングでも効果を発揮します。

既存コードのテストを引き継ぐのはもちろん、既存の仕様を確認しながらテストを拡充できるとなお良く、既存コードに手を加えないことでリスクの少ない安全な移行を実現します。
-->

---

## 高速なレビュー
- チームメンバーの多くがレビューできる状態を目指す
- モブレビューを開催し迅速なマージを目指す
<!--
Swarmingを実践するチームではPRレビューも高速に行われます。

チームメンバー全員にPRの文脈が共有されていると、全員にレビューリクエストが飛び誰かが迅速にレビューに取り組みます。

不確実性が高くApproveまで至りずらいPRでは、モブレビューの会が開かれ意思決定を行います。

レビューはチームメンバーをサポートする機会となり、Swarmingするチームにとって関心が高いトピックです。

-->

---
<!-- footer: 孤独な群れを把握する -->

# 孤独な群れを把握する
- インシデントや顧客問い合わせのような差込対応にもSwarmingを適用する
- 誰か1人に負担が偏る状況を長期化させない

![bg left:50%](./wolf.png)
<!--
私たちのチームではSprintBacklogに対するフィーチャー開発だけではなく、インシデントや顧客問い合わせといった差込対応にもSwarmingを適用しています。

Swarmingのイメージとして紹介されることが多いインシデント対応に群がる様子の通りです。

Swarmingはチームメンバーのメンタルヘルスにも好影響を及ぼします。誰か1人に負担が偏るような状況は長期化させません。メンバーの燃え尽き症候群を防ぐことはどんな状況でも重要です。

-->
---

## Swarmingサークル[^5]
- 誰がどのフィーチャー・差込対応に取り組んでいるのか
- 複数のタスクを兼任しているか

![bg fit right:40%](https://github.com/boykush/documents/blob/main/best_practices_for_swarming_agile_team/swarming_circle.png?raw=true)




[^5]: #16

<!--
孤独な群れを把握できるよう、誰がどのフィーチャー・差込対応に取り組んでいるのか、複数のタスクを抱えていないか、チームメンバー全員がアクセスしやすい場所に可視化をします。以下の様なイメージです。

<img src="https://github.com/boykush/documents/blob/main/best_practices_for_swarming_agile_team/swarming_circle.png?raw=true" width="300px">

複数のタスクを抱えている人はサークル同士が重なる場所にアイコンを置きます。

私たちのチームではこれをSwarmingサークルと呼んでいます。

Swarmingサークルを用いてスクラムイベント等を通して群れの状況を確認し、優先的に消化するサークルを決めチームメンバーのアサインを移動していくことで、サークルの数を少なく保ちます。

とてもシンプルなルールでチームのSwarmingを支えています。

私たちのチームのPdMが発表しているスライド[^5]でもSwarmingサークルに触れられています。
-->

---
<!--footer: 私たちはなぜ群れるのか -->

# 私たちはなぜ群れるのか
- スタートアップの特性上、変化の多い環境において開発プロセスの試行錯誤を頻繁に行っている
- フレームワークを実践する優先度を下げアンラーニングをしていく中で出会ったものがSwarming
- Swarmingはアジャイルチームにとってのスローガン


<!--
ここまでSwarmingをプラクティスとして紹介してきましたが、なぜ群れるのでしょう。

私たちのチームはスタートアップの会社に所属している特性上、変化の多い環境において開発プロセスの試行錯誤を頻繁に行ってきました。

納期ドリブンのプロジェクトが並行して走ってしまいスクラムによるベロシティ計測との相性が悪くなる、等の状況からスクラム、カンバンの両方の導入を経験しています。

そんな中フレームワークを実践する優先度を下げアンラーニングをしていく中で出会ったものがSwarmingです。

「群れる」という概念を中心にアジャイルチームの活動を行っていくことでアジャイル、スクラム文脈での価値や原則を重視しやすくなります。

Swarmingはアジャイルチームにとってのスローガンのようなものです。私たちのチームはこれからも群れながら経験を積んでいきます。

-->

---

# 記事全体の参考リンク

- [Agile Teams Swarm to Greatness](https://brainslink.com/2013/01/agile-teams-swarm-to-greatness/)
- ["群れる" アジャイル / Swarming in Agile](https://speakerdeck.com/i35_267/swarming-in-agile)
- [アジャイルのSwarming（群がる）について](https://medium.com/i35-267/%E3%82%A2%E3%82%B8%E3%83%A3%E3%82%A4%E3%83%AB%E3%81%AEswarming-%E7%BE%A4%E3%81%8C%E3%82%8B-%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6-18831281692)

---

[^1]: Swarmingの粒度を表す図 [アジャイルのSwarming（群がる）について](https://medium.com/i35-267/%E3%82%A2%E3%82%B8%E3%83%A3%E3%82%A4%E3%83%AB%E3%81%AEswarming-%E7%BE%A4%E3%81%8C%E3%82%8B-%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6-18831281692)
[^2]: extensible effectsの参考記事 [Scala + CleanArchitecture に Eff を組み込んでみた](https://blog.recruit.co.jp/rmp/server-side/post-18728/)
[^3]: [DevOpsの能力](https://cloud.google.com/architecture/devops?hl=ja)
[^4]: [StranglerFigApplication](https://martinfowler.com/bliki/StranglerFigApplication.html)
[^5]: Swarmingサークルの紹介スライド [ハイインテグリティコミットメントを実現するスクラム開発の進化](https://speakerdeck.com/kaelaela/evolution-of-scrum-for-high-integrity-commitment)
